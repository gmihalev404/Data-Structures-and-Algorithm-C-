# Кеш Памет

На всеки от вас е позната концепцията за кеш памет - пазят се $N$ на брой елементи, които са най-често използвани. Когато правим заявка за търсене, първо се проверява дали елементът, който търсим, е в кеша, и чак ако не го намерим, търсим в паметта.

Реализирайте кеш памет, която да отговаря на следните заявки:

* **put < x >< y >** - добавя елемент с ключ $x$ и стойност $y$, ако го няма в кеша. Ако го има в кеша, обновява стойността му. И в двата случая това става най-скоро използваният елемент. Ако се опитаме да добавим елемент, когато капацитетът на кеш паметта е запълнен, изхвърляме от нея най-отдавна използвания елемент.
* **get < x >** - отпечатва стойността на елемента с ключ $x$, ако го има в кеша. Отново става най-скоро използваният елемент. Ако го няма в кеша, отпечатва -1.

Вашата кеш памет за съжаление не е от най-мощните и от време на време прегрява. Това се случва след изпълнението на всяка $K$-та заявка. Когато прегрее, се изтрива най-отдавна използвания елемент.

## Input Format

Първият ред на стандартния вход съдържа три цели числа:
1. Капацитета на кеш паметта - $N$
2. Броя на заявките - $Q$
3. Броя на заявки, след които прегрява - $K$

На следващите $Q$ реда получавате заявки от типа `put < x >< y >` или `get < x >`.

## Output Format

За всяка заявка `get < x >` отпечатайте на нов ред стойността на елемента или `-1`, ако ключът не е намерен в кеша.

## Example

**Input:**
```text
2 5 2
put 1 10
put 2 20
get 1
put 3 30
get 2
