# Кеш памет

На всеки от вас е позната концепцията за кеш памет - пазят се $N$ на брой елементи, които са най-често използвани. Когато правим заявка за търсене, първо се проверява дали елементът, който търсим, е в кеша, и чак ако не го намерим, търсим в паметта.

Реализирайте кеш памет, която да отговаря на следните заявки:

* **`put < x >< y >`** - добавя елемент с ключ $x$ и стойност $y$, ако го няма в кеша. Ако го има в кеша, обновява стойността му. И в двата случая това става най-скоро използваният елемент. Ако се опитаме да добавим елемент, когато капацитетът на кеш паметта е запълнен, изхвърляме от нея най-отдавна използвания елемент.

* **`get < x >`** - отпечатва стойността на елемента с ключ $x$, ако го има в кеша. Отново става най-скоро използваният елемент. Ако го няма в кеша, отпечатва -1.



Вашата кеш памет за съжаление не е от най-мощните и от време на време прегрява. Това се случва след изпълнението на всяка К-та заявка. Когато прегрее, се изтрива най-отдавна използвания елемент.

### Input Format

Първият ред на стандартния вход съдържа три цели числа - капацитета на кеш паметта - $N$, броя на заявките - $Q$ и броя на заявки, след които прегрява - $K$. На следващите $Q$ реда получавате заявки от типа $put < x >< y >$ или $get < x >$.

### Constraints

* $1 \le N \le 3000$
* $1 \le Q, K \le 2 * 10^5$
* $0 \le x \le 10^4$
* $0 \le y \le 10^5$

### Output Format

Трябва да изведете отговорите на всяка get заявка на нов ред.

### Sample Input 0

```text
2 9 4
put 1 1
put 2 2
get 1
put 3 3
get 2
put 4 4
get 1
get 3
get 4
```
### Изход (Sample Output 0)

```text
1
-1
-1
3
-1
```
